/* automatically generated by rust-bindgen 0.68.1 */


#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

pub use root::{soundtouch::*, TDStretch, uint};


#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub type uint = libc::c_uint;
    pub mod soundtouch {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type SAMPLETYPE = f32;
        pub type LONG_SAMPLETYPE = f32;
        #[repr(C)]
        pub struct FIFOSamplePipe__bindgen_vtable(libc::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSamplePipe {
            pub vtable_: *const FIFOSamplePipe__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOProcessor {
            pub _base: root::soundtouch::FIFOSamplePipe,
            pub output: *mut root::soundtouch::FIFOSamplePipe,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SoundTouch {
            pub _base: root::soundtouch::FIFOProcessor,
            pub pRateTransposer: *mut root::RateTransposer,
            pub pTDStretch: *mut root::TDStretch,
            pub virtualRate: f64,
            pub virtualTempo: f64,
            pub virtualPitch: f64,
            pub bSrateSet: bool,
            pub samplesExpectedOut: f64,
            pub samplesOutput: libc::c_long,
            pub channels: root::uint,
            pub rate: f64,
            pub tempo: f64,
        }
        extern "C" {
            #[link_name = "\u{1}?getVersionString@SoundTouch@soundtouch@@SAPEBDXZ"]
            pub fn SoundTouch_getVersionString() -> *const libc::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?getVersionId@SoundTouch@soundtouch@@SAIXZ"]
            pub fn SoundTouch_getVersionId() -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?setRate@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setRate(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        extern "C" {
            #[link_name = "\u{1}?setTempo@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setTempo(this: *mut root::soundtouch::SoundTouch, newTempo: f64);
        }
        extern "C" {
            #[link_name = "\u{1}?setRateChange@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setRateChange(this: *mut root::soundtouch::SoundTouch, newRate: f64);
        }
        extern "C" {
            #[link_name = "\u{1}?setTempoChange@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setTempoChange(
                this: *mut root::soundtouch::SoundTouch,
                newTempo: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?setPitch@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitch(this: *mut root::soundtouch::SoundTouch, newPitch: f64);
        }
        extern "C" {
            #[link_name = "\u{1}?setPitchOctaves@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitchOctaves(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?setPitchSemiTones@SoundTouch@soundtouch@@QEAAXH@Z"]
            pub fn SoundTouch_setPitchSemiTones(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?setPitchSemiTones@SoundTouch@soundtouch@@QEAAXN@Z"]
            pub fn SoundTouch_setPitchSemiTones1(
                this: *mut root::soundtouch::SoundTouch,
                newPitch: f64,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?setChannels@SoundTouch@soundtouch@@QEAAXI@Z"]
            pub fn SoundTouch_setChannels(
                this: *mut root::soundtouch::SoundTouch,
                numChannels: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?setSampleRate@SoundTouch@soundtouch@@QEAAXI@Z"]
            pub fn SoundTouch_setSampleRate(
                this: *mut root::soundtouch::SoundTouch,
                srate: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?getInputOutputSampleRatio@SoundTouch@soundtouch@@QEAANXZ"]
            pub fn SoundTouch_getInputOutputSampleRatio(
                this: *mut root::soundtouch::SoundTouch,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}?flush@SoundTouch@soundtouch@@QEAAXXZ"]
            pub fn SoundTouch_flush(this: *mut root::soundtouch::SoundTouch);
        }
        extern "C" {
            #[link_name = "\u{1}?setSetting@SoundTouch@soundtouch@@QEAA_NHH@Z"]
            pub fn SoundTouch_setSetting(
                this: *mut root::soundtouch::SoundTouch,
                settingId: libc::c_int,
                value: libc::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?getSetting@SoundTouch@soundtouch@@QEBAHH@Z"]
            pub fn SoundTouch_getSetting(
                this: *const root::soundtouch::SoundTouch,
                settingId: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}??0SoundTouch@soundtouch@@QEAA@XZ"]
            pub fn SoundTouch_SoundTouch(this: *mut root::soundtouch::SoundTouch);
        }
        impl SoundTouch {
            #[inline]
            pub unsafe fn getVersionString() -> *const libc::c_char {
                SoundTouch_getVersionString()
            }
            #[inline]
            pub unsafe fn getVersionId() -> root::uint {
                SoundTouch_getVersionId()
            }
            #[inline]
            pub unsafe fn setRate(&mut self, newRate: f64) {
                SoundTouch_setRate(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempo(&mut self, newTempo: f64) {
                SoundTouch_setTempo(self, newTempo)
            }
            #[inline]
            pub unsafe fn setRateChange(&mut self, newRate: f64) {
                SoundTouch_setRateChange(self, newRate)
            }
            #[inline]
            pub unsafe fn setTempoChange(&mut self, newTempo: f64) {
                SoundTouch_setTempoChange(self, newTempo)
            }
            #[inline]
            pub unsafe fn setPitch(&mut self, newPitch: f64) {
                SoundTouch_setPitch(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchOctaves(&mut self, newPitch: f64) {
                SoundTouch_setPitchOctaves(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones(&mut self, newPitch: libc::c_int) {
                SoundTouch_setPitchSemiTones(self, newPitch)
            }
            #[inline]
            pub unsafe fn setPitchSemiTones1(&mut self, newPitch: f64) {
                SoundTouch_setPitchSemiTones1(self, newPitch)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: root::uint) {
                SoundTouch_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn setSampleRate(&mut self, srate: root::uint) {
                SoundTouch_setSampleRate(self, srate)
            }
            #[inline]
            pub unsafe fn getInputOutputSampleRatio(&mut self) -> f64 {
                SoundTouch_getInputOutputSampleRatio(self)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                SoundTouch_flush(self)
            }
            #[inline]
            pub unsafe fn setSetting(
                &mut self,
                settingId: libc::c_int,
                value: libc::c_int,
            ) -> bool {
                SoundTouch_setSetting(self, settingId, value)
            }
            #[inline]
            pub unsafe fn getSetting(&self, settingId: libc::c_int) -> libc::c_int {
                SoundTouch_getSetting(self, settingId)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                SoundTouch_SoundTouch(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DSoundTouch@soundtouch@@QEAAXXZ"]
            pub fn SoundTouch_SoundTouch_destructor(this: *mut root::soundtouch::SoundTouch);
        }
        extern "C" {
            #[link_name = "\u{1}?putSamples@SoundTouch@soundtouch@@UEAAXPEBMI@Z"]
            pub fn SoundTouch_putSamples(
                this: *mut libc::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?receiveSamples@SoundTouch@soundtouch@@UEAAIPEAMI@Z"]
            pub fn SoundTouch_receiveSamples(
                this: *mut libc::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?receiveSamples@SoundTouch@soundtouch@@UEAAII@Z"]
            pub fn SoundTouch_receiveSamples1(
                this: *mut libc::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?clear@SoundTouch@soundtouch@@UEAAXXZ"]
            pub fn SoundTouch_clear(this: *mut libc::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?numUnprocessedSamples@SoundTouch@soundtouch@@UEBAIXZ"]
            pub fn SoundTouch_numUnprocessedSamples(this: *mut libc::c_void) -> root::uint;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct FIFOSampleBuffer {
            pub _base: root::soundtouch::FIFOSamplePipe,
            pub buffer: *mut root::soundtouch::SAMPLETYPE,
            pub bufferUnaligned: *mut root::soundtouch::SAMPLETYPE,
            pub sizeInBytes: root::uint,
            pub samplesInBuffer: root::uint,
            pub channels: root::uint,
            pub bufferPos: root::uint,
        }
        extern "C" {
            #[link_name = "\u{1}?ptrEnd@FIFOSampleBuffer@soundtouch@@QEAAPEAMI@Z"]
            pub fn FIFOSampleBuffer_ptrEnd(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        extern "C" {
            #[link_name = "\u{1}?setChannels@FIFOSampleBuffer@soundtouch@@QEAAXH@Z"]
            pub fn FIFOSampleBuffer_setChannels(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?addSilent@FIFOSampleBuffer@soundtouch@@QEAAXI@Z"]
            pub fn FIFOSampleBuffer_addSilent(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                nSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0FIFOSampleBuffer@soundtouch@@QEAA@H@Z"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer(
                this: *mut root::soundtouch::FIFOSampleBuffer,
                numChannels: libc::c_int,
            );
        }
        impl FIFOSampleBuffer {
            #[inline]
            pub unsafe fn ptrEnd(
                &mut self,
                slackCapacity: root::uint,
            ) -> *mut root::soundtouch::SAMPLETYPE {
                FIFOSampleBuffer_ptrEnd(self, slackCapacity)
            }
            #[inline]
            pub unsafe fn setChannels(&mut self, numChannels: libc::c_int) {
                FIFOSampleBuffer_setChannels(self, numChannels)
            }
            #[inline]
            pub unsafe fn addSilent(&mut self, nSamples: root::uint) {
                FIFOSampleBuffer_addSilent(self, nSamples)
            }
            #[inline]
            pub unsafe fn new(numChannels: libc::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                FIFOSampleBuffer_FIFOSampleBuffer(__bindgen_tmp.as_mut_ptr(), numChannels);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DFIFOSampleBuffer@soundtouch@@QEAAXXZ"]
            pub fn FIFOSampleBuffer_FIFOSampleBuffer_destructor(
                this: *mut root::soundtouch::FIFOSampleBuffer,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ptrBegin@FIFOSampleBuffer@soundtouch@@UEAAPEAMXZ"]
            pub fn FIFOSampleBuffer_ptrBegin(
                this: *mut libc::c_void,
            ) -> *mut root::soundtouch::SAMPLETYPE;
        }
        extern "C" {
            #[link_name = "\u{1}?putSamples@FIFOSampleBuffer@soundtouch@@UEAAXPEBMI@Z"]
            pub fn FIFOSampleBuffer_putSamples(
                this: *mut libc::c_void,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: root::uint,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?putSamples@FIFOSampleBuffer@soundtouch@@UEAAXI@Z"]
            pub fn FIFOSampleBuffer_putSamples1(this: *mut libc::c_void, numSamples: root::uint);
        }
        extern "C" {
            #[link_name = "\u{1}?receiveSamples@FIFOSampleBuffer@soundtouch@@UEAAIPEAMI@Z"]
            pub fn FIFOSampleBuffer_receiveSamples(
                this: *mut libc::c_void,
                output: *mut root::soundtouch::SAMPLETYPE,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?receiveSamples@FIFOSampleBuffer@soundtouch@@UEAAII@Z"]
            pub fn FIFOSampleBuffer_receiveSamples1(
                this: *mut libc::c_void,
                maxSamples: root::uint,
            ) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?numSamples@FIFOSampleBuffer@soundtouch@@UEBAIXZ"]
            pub fn FIFOSampleBuffer_numSamples(this: *mut libc::c_void) -> root::uint;
        }
        extern "C" {
            #[link_name = "\u{1}?isEmpty@FIFOSampleBuffer@soundtouch@@UEBAHXZ"]
            pub fn FIFOSampleBuffer_isEmpty(this: *mut libc::c_void) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?clear@FIFOSampleBuffer@soundtouch@@UEAAXXZ"]
            pub fn FIFOSampleBuffer_clear(this: *mut libc::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?adjustAmountOfSamples@FIFOSampleBuffer@soundtouch@@UEAAII@Z"]
            pub fn FIFOSampleBuffer_adjustAmountOfSamples(
                this: *mut libc::c_void,
                numSamples: root::uint,
            ) -> root::uint;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BEAT {
            pub pos: f32,
            pub strength: f32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IIR2_filter {
            pub coeffs: [f64; 5usize],
            pub prev: [f64; 5usize],
        }
        extern "C" {
            #[link_name = "\u{1}?update@IIR2_filter@soundtouch@@QEAAMM@Z"]
            pub fn IIR2_filter_update(this: *mut root::soundtouch::IIR2_filter, x: f32) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}??0IIR2_filter@soundtouch@@QEAA@PEBN@Z"]
            pub fn IIR2_filter_IIR2_filter(
                this: *mut root::soundtouch::IIR2_filter,
                lpf_coeffs: *const f64,
            );
        }
        impl IIR2_filter {
            #[inline]
            pub unsafe fn update(&mut self, x: f32) -> f32 {
                IIR2_filter_update(self, x)
            }
            #[inline]
            pub unsafe fn new(lpf_coeffs: *const f64) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                IIR2_filter_IIR2_filter(__bindgen_tmp.as_mut_ptr(), lpf_coeffs);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct BPMDetect__bindgen_vtable(libc::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct BPMDetect {
            pub vtable_: *const BPMDetect__bindgen_vtable,
            pub xcorr: *mut f32,
            pub decimateCount: libc::c_int,
            pub decimateSum: root::soundtouch::LONG_SAMPLETYPE,
            pub decimateBy: libc::c_int,
            pub windowLen: libc::c_int,
            pub channels: libc::c_int,
            pub sampleRate: libc::c_int,
            pub windowStart: libc::c_int,
            pub hamw: *mut f32,
            pub hamw2: *mut f32,
            pub pos: libc::c_int,
            pub peakPos: libc::c_int,
            pub beatcorr_ringbuffpos: libc::c_int,
            pub init_scaler: libc::c_int,
            pub peakVal: f32,
            pub beatcorr_ringbuff: *mut f32,
            pub buffer: *mut root::soundtouch::FIFOSampleBuffer,
            pub beats: [u64; 3usize],
            pub beat_lpf: root::soundtouch::IIR2_filter,
        }
        extern "C" {
            #[link_name = "\u{1}?updateXCorr@BPMDetect@soundtouch@@IEAAXH@Z"]
            pub fn BPMDetect_updateXCorr(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?decimate@BPMDetect@soundtouch@@IEAAHPEAMPEBMH@Z"]
            pub fn BPMDetect_decimate(
                this: *mut root::soundtouch::BPMDetect,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?removeBias@BPMDetect@soundtouch@@IEAAXXZ"]
            pub fn BPMDetect_removeBias(this: *mut root::soundtouch::BPMDetect);
        }
        extern "C" {
            #[link_name = "\u{1}?updateBeatPos@BPMDetect@soundtouch@@IEAAXH@Z"]
            pub fn BPMDetect_updateBeatPos(
                this: *mut root::soundtouch::BPMDetect,
                process_samples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?inputSamples@BPMDetect@soundtouch@@QEAAXPEBMH@Z"]
            pub fn BPMDetect_inputSamples(
                this: *mut root::soundtouch::BPMDetect,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: libc::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?getBpm@BPMDetect@soundtouch@@QEAAMXZ"]
            pub fn BPMDetect_getBpm(this: *mut root::soundtouch::BPMDetect) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}?getBeats@BPMDetect@soundtouch@@QEAAHPEAM0H@Z"]
            pub fn BPMDetect_getBeats(
                this: *mut root::soundtouch::BPMDetect,
                pos: *mut f32,
                strength: *mut f32,
                max_num: libc::c_int,
            ) -> libc::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}??0BPMDetect@soundtouch@@QEAA@HH@Z"]
            pub fn BPMDetect_BPMDetect(
                this: *mut root::soundtouch::BPMDetect,
                numChannels: libc::c_int,
                sampleRate: libc::c_int,
            );
        }
        impl BPMDetect {
            #[inline]
            pub unsafe fn updateXCorr(&mut self, process_samples: libc::c_int) {
                BPMDetect_updateXCorr(self, process_samples)
            }
            #[inline]
            pub unsafe fn decimate(
                &mut self,
                dest: *mut root::soundtouch::SAMPLETYPE,
                src: *const root::soundtouch::SAMPLETYPE,
                numsamples: libc::c_int,
            ) -> libc::c_int {
                BPMDetect_decimate(self, dest, src, numsamples)
            }
            #[inline]
            pub unsafe fn removeBias(&mut self) {
                BPMDetect_removeBias(self)
            }
            #[inline]
            pub unsafe fn updateBeatPos(&mut self, process_samples: libc::c_int) {
                BPMDetect_updateBeatPos(self, process_samples)
            }
            #[inline]
            pub unsafe fn inputSamples(
                &mut self,
                samples: *const root::soundtouch::SAMPLETYPE,
                numSamples: libc::c_int,
            ) {
                BPMDetect_inputSamples(self, samples, numSamples)
            }
            #[inline]
            pub unsafe fn getBpm(&mut self) -> f32 {
                BPMDetect_getBpm(self)
            }
            #[inline]
            pub unsafe fn getBeats(
                &mut self,
                pos: *mut f32,
                strength: *mut f32,
                max_num: libc::c_int,
            ) -> libc::c_int {
                BPMDetect_getBeats(self, pos, strength, max_num)
            }
            #[inline]
            pub unsafe fn new(numChannels: libc::c_int, sampleRate: libc::c_int) -> Self {
                let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
                BPMDetect_BPMDetect(__bindgen_tmp.as_mut_ptr(), numChannels, sampleRate);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DBPMDetect@soundtouch@@QEAAXXZ"]
            pub fn BPMDetect_BPMDetect_destructor(this: *mut root::soundtouch::BPMDetect);
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__From_primary = u8;
        pub type allocator_value_type = u8;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Alty = u8;
        pub type vector__Alty_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector__Scary_val = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub const vector__Reallocation_policy__At_least: root::std::vector__Reallocation_policy = 0;
        pub const vector__Reallocation_policy__Exactly: root::std::vector__Reallocation_policy = 0;
        pub type vector__Reallocation_policy = libc::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RateTransposer {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct TDStretch {
        pub _address: u8,
    }
}
